#define MLTON_GC_INTERNAL_TYPES
#define MLTON_GC_INTERNAL_FUNCS
#define MLTON_GC_INTERNAL_BASIS
#include "platform.h"

int frameLayouts_len = 1;
static int our_init_is_done = 0;

#include "gc.h"
uint32_t objectTypes_len = 4;
static struct GC_objectType objectTypes[] = {
		{STACK_TAG,  FALSE, 0,  0}, /* 0 */
		{NORMAL_TAG, TRUE,  24, 0}, /* 1 */
		{WEAK_TAG,   FALSE, 8,  0}, /* 2 */
		{ARRAY_TAG,  FALSE, 1,  0}  /* 3 */
};

uint32_t sourceSeqs_len = 0;
static uint32_t* sourceSeqs[] = {
};
uint32_t frameSources_len = 0;
static GC_sourceSeqIndex frameSources[] = {
};
uint32_t sourceLabels_len = 0;
static struct GC_sourceLabel sourceLabels[] = {
};
uint32_t sourceNames_len = 0;
static char* sourceNames[] = {
};
uint32_t sources_len = 0;
static struct GC_source sources[] = {
};
uint32_t atMLtons_len = 2;
static char* atMLtons[] = {
		"@MLton", /* 0 */
		"--", /* 1 */
};

struct GC_state gcState;
void setup(void)
{
	if (our_init_is_done == 1) return;
	our_init_is_done = 1;
	fprintf(stderr, "setup\n");
	gcState.alignment = sizeof(void *);
    gcState.atMLtons = NULL;
	gcState.atMLtonsLength = 0;
	gcState.frameLayouts = NULL;
	gcState.frameLayoutsLength = 0;
	gcState.globals = (objptr*)NULL;
	gcState.globalsLength = 0;
	gcState.magic = 0x2112;
	gcState.maxFrameSize = UM_CHUNK_PAYLOAD_SIZE;
	gcState.objectTypes = objectTypes;
	gcState.objectTypesLength = objectTypes_len;
	gcState.vectorInits = NULL;
	gcState.vectorInitsLength = 0;
	gcState.sourceMaps.frameSources = frameSources;
	gcState.sourceMaps.frameSourcesLength = cardof(frameSources);
	gcState.sourceMaps.sourceLabels = sourceLabels;
	gcState.sourceMaps.sourceLabelsLength = cardof(sourceLabels);
	gcState.sourceMaps.sourceNames = sourceNames;
	gcState.sourceMaps.sourceNamesLength = cardof(sourceNames);
	gcState.sourceMaps.sourceSeqs = sourceSeqs;
	gcState.sourceMaps.sourceSeqsLength = 0; //cardof(sourceSeqs);
	gcState.sourceMaps.sources = sources;
	gcState.sourceMaps.sourcesLength = cardof(sources);
	gcState.profiling.isOn = FALSE;

	char argv[0] = {NULL};
	MLton_init (0, (char**)&argv, &gcState);
}

int count_leafs(pointer r) {
	int c = 0;
	pointer n = r;
	while ((n = UM_walk_array_leafs(n, NULL))) {
		c++;
	}
	return c;
}
void teardown(void)
{
	fprintf(stderr, "teardown\n");
}

#test array_alloc_1_test
    pointer a = GC_arrayAllocate(&gcState, 0, 1, (0x3<<1) | 0x1);
	struct GC_UM_Array_Chunk *root = (struct GC_UM_Array_Chunk *)(a - 2*(sizeof(void *)));
	fail_unless (root->array_height == 0, "height not 0 (root only)");
	fail_unless (root->array_chunk_magic == UM_ARRAY_SENTINEL, "magic wrong");
	fail_unless (root->array_chunk_length == 1, "array len not 1?");
	fail_unless (root->array_chunk_type == UM_CHUNK_ARRAY_LEAF, "root should be LEAF");

#test array_alloc_2_test
	pointer a = GC_arrayAllocate(&gcState, 0, 2, (0x3<<1) | 0x1);
	struct GC_UM_Array_Chunk *root = (struct GC_UM_Array_Chunk *)(a - 2*(sizeof(void *)));
	fail_unless (root->array_height == 0, "height not 0 (root only)");
	fail_unless (root->array_chunk_magic == UM_ARRAY_SENTINEL, "magic wrong");
	fail_unless (root->array_chunk_length == 2, "array len not 2?");
	fail_unless (root->array_chunk_type == UM_CHUNK_ARRAY_LEAF, "root should be LEAF");

#test array_alloc_full_root_chunk_test
	/* should fit in one chunk still */
	pointer a = GC_arrayAllocate(&gcState, 0, UM_CHUNK_ARRAY_PAYLOAD_SIZE, (0x3<<1) | 0x1);
	struct GC_UM_Array_Chunk *root = (struct GC_UM_Array_Chunk *)(a - 2*(sizeof(void *)));
	fail_unless (root->array_height == 0, "height not 0 (root only)");
	fail_unless (root->array_chunk_magic == UM_ARRAY_SENTINEL, "magic wrong");
	fail_unless (root->array_chunk_length == UM_CHUNK_ARRAY_PAYLOAD_SIZE, "array len not UM_CHUNK_ARRAY_PAYLOAD_SIZE?");
	fail_unless (root->array_chunk_type == UM_CHUNK_ARRAY_LEAF, "root should be LEAF");

#test array_alloc_full_root_plus_one_test
	/* UM_CHUNK_ARRAY_PAYLOAD_SIZE+1 elements req 2 leafs + 1 root */
	pointer a = GC_arrayAllocate(&gcState, 0, UM_CHUNK_ARRAY_PAYLOAD_SIZE+1, (0x3<<1) | 0x1);
	struct GC_UM_Array_Chunk *root = (struct GC_UM_Array_Chunk *)(a - 2*(sizeof(void *)));
	fail_unless (root->array_height == 1, "height not 1 (root + leafs)");
	fail_unless (root->array_chunk_magic == UM_ARRAY_SENTINEL, "magic wrong");
	fail_unless (root->array_chunk_length == UM_CHUNK_ARRAY_PAYLOAD_SIZE+1, "array len not UM_CHUNK_ARRAY_PAYLOAD_SIZE+1?");
	fail_unless (root->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL, "root should be INTERNAL");
	int c = count_leafs(a);
	fail_unless (c == 2, "should have only 2 leafs");

#test array_alloc_fully_populated_height_1_test
	/* UM_CHUNK_ARRAY_INTERNAL_POINTERS * UM_CHUNK_ARRAY_PAYLOAD_SIZE elements reqs
	 * UM_CHUNK_ARRAY_INTERNAL_POINTERS leafs + 1 root
	 * this means height must be 1 and c must be UM_CHUNK_ARRAY_INTERNAL_POINTERS
	 */
	int nels = UM_CHUNK_ARRAY_INTERNAL_POINTERS * UM_CHUNK_ARRAY_PAYLOAD_SIZE;
	pointer a = GC_arrayAllocate(&gcState, 0, nels, (0x3<<1) | 0x1);
	struct GC_UM_Array_Chunk *root = (struct GC_UM_Array_Chunk *)(a - 2*(sizeof(void *)));
	fail_unless (root->array_height == 1, "height not 1 (root + leafs)");
	fail_unless (root->array_chunk_magic == UM_ARRAY_SENTINEL, "magic wrong");
	fail_unless (root->array_chunk_length == nels, "array len not correct?");
	fail_unless (root->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL, "root should be INTERNAL");
	int c = count_leafs(a);
	fail_unless (c == UM_CHUNK_ARRAY_INTERNAL_POINTERS, "should have UM_CHUNK_ARRAY_INTERNAL_POINTERS leafs");

#test array_alloc_fully_populated_height_1_plus_1_test
	/* UM_CHUNK_ARRAY_INTERNAL_POINTERS * UM_CHUNK_ARRAY_PAYLOAD_SIZE elements reqs
	 * UM_CHUNK_ARRAY_INTERNAL_POINTERS leafs + 1 root
	 *
	 * if we add one more element, it forces us to height 2 and one additional leaf.
	 *
	 * so what we should have is a root, two internal nodes, the first of which is
	 * fully populated, the 2nd has only one leaf attached to it, the rest of the internal
	 * nodes are unallocated.
	 *
	 * this means height must be 1 and c must be UM_CHUNK_ARRAY_INTERNAL_POINTERS
	 */
	int nels = UM_CHUNK_ARRAY_INTERNAL_POINTERS * UM_CHUNK_ARRAY_PAYLOAD_SIZE + 1;
	pointer a = GC_arrayAllocate(&gcState, 0, nels, (0x3<<1) | 0x1);
	struct GC_UM_Array_Chunk *root = (struct GC_UM_Array_Chunk *)(a - 2*(sizeof(void *)));
	fail_unless (root->array_height == 2, "height not 2 (root + 1 internal layer + leafs)");
	fail_unless (root->array_chunk_magic == UM_ARRAY_SENTINEL, "magic wrong");
	fail_unless (root->array_chunk_length == nels, "array len not correct?");
	fail_unless (root->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL, "root should be INTERNAL");
	fail_unless (root->ml_array_payload.um_array_pointers[0]->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL, "root->internal[0] should be INTERNAL");
	fail_unless (root->ml_array_payload.um_array_pointers[1]->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL, "root->internal[1] should be INTERNAL");
	for (int i = 2 ; i < UM_CHUNK_ARRAY_INTERNAL_POINTERS ; i++)
		fail_unless (root->ml_array_payload.um_array_pointers[i] == NULL, "root->internal[2..N] should be NULL");
	int c = count_leafs(a);
	fail_unless (c == UM_CHUNK_ARRAY_INTERNAL_POINTERS, "should have UM_CHUNK_ARRAY_INTERNAL_POINTERS leafs");

#test array_alloc_H3_test
	/* (UM_CHUNK_ARRAY_INTERNAL_POINTERS^2) * UM_CHUNK_ARRAY_PAYLOAD_SIZE elements reqs
	 * UM_CHUNK_ARRAY_INTERNAL_POINTERS^2 leafs
	 *
	 * if we add one more element, it forces us to height 3. which is 4 layers:
	 * H0 is root, H1 contains 1 I's, H2 contains 75 I's used out of a possible 75^2,
	 * H3 contains 75^2 + 1 I's
	 *
	 * this means that H1 contains only 1 I
	 * H2 contains 75^2 I's
	 * this means height must be 3 and c must be UM_CHUNK_ARRAY_INTERNAL_POINTERS^2+1
	 */
	int nleafs = UM_CHUNK_ARRAY_INTERNAL_POINTERS * UM_CHUNK_ARRAY_INTERNAL_POINTERS;
	int nels = nleafs * UM_CHUNK_ARRAY_PAYLOAD_SIZE + 1;
	fprintf(stderr, "nleafs %d nels %d\n", nleafs, nels);
	pointer a = GC_arrayAllocate(&gcState, 0, nels, (0x3<<1) | 0x1);
	struct GC_UM_Array_Chunk *root = (struct GC_UM_Array_Chunk *)(a - 2*(sizeof(void *)));
	fail_unless (root->array_height == 3, "height not 3 (root + 1 internal layer + leafs)");
	fail_unless (root->array_chunk_magic == UM_ARRAY_SENTINEL, "magic wrong");
	fail_unless (root->array_chunk_length == nels, "array len not correct?");
	fail_unless (root->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL, "root should be INTERNAL");

	// root should have one Inode off of it
	fail_unless (root->ml_array_payload.um_array_pointers[0]->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL,
	             "root->internal[0] should be INTERNAL");
	for (int i = 1 ; i < UM_CHUNK_ARRAY_INTERNAL_POINTERS ; i++)
	    fail_unless (root->ml_array_payload.um_array_pointers[i] == NULL, "root->internal[2..N] should be NULL");

	// that Inode should have 75 Inodes hung off of it
	struct GC_UM_Array_Chunk *H1_inode = root->ml_array_payload.um_array_pointers[0];
    for (int i = 0 ; i < UM_CHUNK_ARRAY_INTERNAL_POINTERS ; i++) {
        fail_if (H1_inode == NULL, "all of H1_inode's children should be populated");
        fail_unless (H1_inode->ml_array_payload.um_array_pointers[i]->array_chunk_type == UM_CHUNK_ARRAY_INTERNAL,
                     "H1_inode->internal[0..N] should also be Inodes");
    }

	int c = count_leafs(a);
	fail_unless (c == UM_CHUNK_ARRAY_INTERNAL_POINTERS, "should have UM_CHUNK_ARRAY_INTERNAL_POINTERS leafs");


#main-pre
	tcase_add_checked_fixture(tc1_1, setup, NULL);
